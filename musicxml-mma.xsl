<?xml version="1.0" encoding="UTF-8"?>
<xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
  xmlns:xs="http://www.w3.org/2001/XMLSchema"
  xmlns:mma="http://www.mellowood.ca/mma"
  exclude-result-prefixes="xs mma"
  version="2.0"
>
<xsl:output media-type="text/plain" omit-xml-declaration="yes"/>

<!-- Inspired by https://github.com/k8bushlover/XSLT-MusicXmlToSessionBand - I love k8bush too! -->

<xsl:param name="chordVolume" select="50"/>
<xsl:param name="soloVoice" select="'TenorSax'"/>
<xsl:param name="chordVoice" select="'Piano1'"/>
<xsl:param name="globalGroove"/>

<xsl:variable name="divisions" select="score-partwise/part/measure/attributes/divisions"/>
<xsl:variable name="beats" select="score-partwise/part/measure/attributes/time/beats"/>
<xsl:variable name="beatType" select="score-partwise/part/measure/attributes/time/beat-type"/>

<xsl:template match="score-partwise">
<xsl:text>
// Generated by musicxml-mma converter https://github.com/infojunkie/musicxml-mma

// Custom chord voice
Begin Chord-Custom
  Voice </xsl:text><xsl:value-of select="$chordVoice"/><xsl:text>
  Octave 5
  Articulate 80
  Volume f
End

Solo Voice </xsl:text><xsl:value-of select="$soloVoice"/><xsl:text>

// Custom chord definitions
DefChord 7(add6) (0, 4, 7, 9, 10) (0, 2, 4, 5, 7, 9, 10)
DefChord +(addM7)(add9) (0, 4, 8, 11, 14) (0, 2, 4, 5, 8, 9, 11)
DefChord 7+#9 (0, 4, 8, 10, 15) (0, 3, 4, 5, 8, 9, 10)
DefChord M7+ (0, 4, 8, 11) (0, 2, 4, 5, 8, 9, 11)
DefChord dimb13 (0, 3, 6, 9, 8) (0, 2, 3, 5, 6, 8, 9)
DefChord m7+#9 (0, 3, 8, 10, 15) (0, 3, 3, 5, 8, 8, 10)
DefChord m7+b9 (0, 3, 8, 10, 13) (0, 1, 3, 5, 8, 8, 10)
DefChord m7+b9#11 (0, 3, 8, 10, 13, 18) (0, 1, 3, 6, 8, 9, 10)
DefChord m7+ (0, 3, 7, 11) (0, 2, 3, 5, 7, 8, 11)
DefChord (omit3)(add9) (0, 0, 7, 14) (0, 2, 4, 5, 7, 9, 10)
DefChord sus#9 (0, 5, 7, 15) (0, 2, 5, 5, 7, 9, 11)
DefChord susb9 (0, 5, 7, 13) (0, 2, 5, 5, 7, 9, 11)

Plugin Slash</xsl:text>
  <xsl:apply-templates select="//harmony[bass]" mode="slash">
    <xsl:with-param name="definition" select="true()"/>
  </xsl:apply-templates>
  <xsl:text>&#xa;</xsl:text>

  <xsl:apply-templates select="part/measure[1]">
    <xsl:with-param name="lastHarmony"/>
    <xsl:with-param name="repeatMeasure" select="part/measure[1]"/>
    <xsl:with-param name="repeatCount" select="1"/>
    <xsl:with-param name="jump"/>
    <xsl:with-param name="lastGroove"/>
    <xsl:with-param name="lastMeasure"/>
  </xsl:apply-templates>
</xsl:template>

<!--
  Unroll the repeats and jumps into a linear sequence of measures. To do this, we advance measure by measure, carrying a state made of:
  - Last chord we saw (to set in current measure in case it's empty)
  - Last groove
  - Last measure
  - Current loop starting measure, typically indicated by a forward-facing repeat barline
  - Current loop counter
  - Current jump status
  Based on the current measure's repeats and jumps, and the current state, we choose which measure to output next.
-->
<xsl:template match="measure">
  <xsl:param name="lastHarmony"/>
  <xsl:param name="lastGroove"/>
  <xsl:param name="lastMeasure"/>
  <xsl:param name="repeatMeasure"/>
  <xsl:param name="repeatCount" as="xs:integer"/>
  <xsl:param name="jump"/>

  <xsl:variable name="nextHarmony" select="if (count(harmony) = 0) then $lastHarmony else harmony[last()]"/>

  <!--
    Calculate this measure's groove.
    If we have a global groove override, set it the first time around. It will override any groove command in the file.
    Otherwise, detect a sound/play/other-play[@type = groove] element and derive the groove from it.
    Remember the last seen groove to avoid redeclaring at each measure.
  -->
  <xsl:variable name="thisGroove">
    <xsl:choose>
      <xsl:when test="$globalGroove != '' and $lastGroove != $globalGroove and lower-case($globalGroove) != 'none'">
        <xsl:value-of select="$globalGroove"/>
      </xsl:when>
      <xsl:when test="$globalGroove != ''"></xsl:when>
      <xsl:otherwise>
        <xsl:apply-templates select="*/sound/play/other-play[@type = 'groove']" mode="groove"/>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:variable>
  <xsl:variable name="nextGroove" select="if ($thisGroove != '') then $thisGroove else $lastGroove"/>

  <!-- Alternate ending start: Skip to the matching following alternate ending if the loop counter isn't mentioned in the current ending. -->
  <xsl:choose><xsl:when test="barline[ending/@type = 'start'] and not(index-of(tokenize(barline/ending[@type = 'start']/@number, '\s*,\s*'), format-number($repeatCount, '0')))">
    <xsl:apply-templates select="following-sibling::measure[barline/ending/@type = 'start' and index-of(tokenize(barline/ending[@type = 'start']/@number, '\s*,\s*'), format-number($repeatCount, '0'))][1]">
      <xsl:with-param name="lastHarmony" select="$nextHarmony"/>
      <xsl:with-param name="repeatMeasure" select="$repeatMeasure"/>
      <xsl:with-param name="repeatCount" select="$repeatCount"/>
      <xsl:with-param name="jump" select="$jump"/>
      <xsl:with-param name="lastGroove" select="$nextGroove"/>
      <xsl:with-param name="lastMeasure" select="."/>
    </xsl:apply-templates>
  </xsl:when>
  <xsl:otherwise>

  <xsl:apply-templates select="attributes/time"/>
  <xsl:apply-templates select="direction/sound[@tempo]" mode="tempo"/>

  <!-- If we don't have a groove, add our hand-made chord sequence that replicates the rhythm notation of the chords. -->
  <xsl:choose>
    <xsl:when test="$thisGroove != ''">
Groove <xsl:value-of select="$thisGroove"/>
MidiMark Groove:<xsl:value-of select="$thisGroove"/>
    </xsl:when>
    <xsl:when test="$lastGroove != ''"></xsl:when>
    <xsl:otherwise>
      <xsl:apply-templates select="harmony[1]" mode="sequence">
        <xsl:with-param name="start" select="1"/>
      </xsl:apply-templates>
      <xsl:if test="count(harmony) = 0">
        <!-- In case of no chord in this measure, get the last chord of the closest preceding measure that had a chord. -->
        <xsl:apply-templates select="$lastHarmony" mode="sequence">
          <xsl:with-param name="start" select="1"/>
        </xsl:apply-templates>
      </xsl:if>
    </xsl:otherwise>
  </xsl:choose>

  <!-- Measure number. -->
  <xsl:text>&#xa;</xsl:text>
  <xsl:text>MidiMark Measure:</xsl:text><xsl:value-of select="@number"/>
  <xsl:text>&#xa;</xsl:text>
  <xsl:value-of select="@number"/>

  <!-- Chord information. -->
  <xsl:apply-templates select="harmony[1]" mode="chords">
    <xsl:with-param name="start" select="1"/>
  </xsl:apply-templates>
  <xsl:if test="count(harmony) = 0">
    <!-- In case of no chord in this measure, get the last chord of the closest preceding measure that had a chord. -->
    <xsl:if test="not($lastHarmony)"> z</xsl:if>
    <xsl:apply-templates select="$lastHarmony" mode="chords">
      <xsl:with-param name="start" select="1"/>
    </xsl:apply-templates>
  </xsl:if>

  <!-- Notes information. -->
  <xsl:apply-templates select="note[1]">
    <xsl:with-param name="shouldIgnoreTieStop" select="if (not($lastMeasure)) then false() else not($lastMeasure/note[not(chord)][last()]/tie[@type = 'start'])"/>
    <xsl:with-param name="isAnyNotePrinted" select="false()"/>
  </xsl:apply-templates>

  <!-- Advance to next measure with our unrolling algorithm. -->
  <xsl:choose>
    <!-- Fine: Stop everything
         TODO Handle sound/@time-only for alternate endings.
    -->
    <xsl:when test="*/sound/@fine = 'yes' and $jump != ''">
    </xsl:when>
    <!-- To Coda: Jump forward to labeled coda
         TODO Handle sound/@time-only for alternate endings.
    -->
    <xsl:when test="*/sound[@tocoda] and not($jump = '')">
      <xsl:variable name="coda" select="*/sound/@tocoda"/>
      <xsl:apply-templates select="following-sibling::measure[*/sound/@coda = $coda]">
        <xsl:with-param name="lastHarmony"/>
        <xsl:with-param name="repeatMeasure" select="//measure[1]"/>
        <xsl:with-param name="repeatCount" select="1"/>
        <xsl:with-param name="jump" select="$coda"/>
        <xsl:with-param name="lastGroove" select="$nextGroove"/>
        <xsl:with-param name="lastMeasure" select="."/>
      </xsl:apply-templates>
    </xsl:when>
    <!-- Opening repeat: Save this measure as the loop start. Reset loop counter to 1 unless we're already looping.
         TODO Handle sound/@forward-repeat attribute for the same effect.
    -->
    <xsl:when test="barline/repeat/@direction = 'forward' or generate-id(.) = generate-id($repeatMeasure)">
      <xsl:apply-templates select="following-sibling::measure[1]">
        <xsl:with-param name="lastHarmony" select="$nextHarmony"/>
        <xsl:with-param name="repeatMeasure" select="."/>
        <xsl:with-param name="repeatCount" select="if (generate-id(.) = generate-id($repeatMeasure)) then $repeatCount else 1"/>
        <xsl:with-param name="jump" select="$jump"/>
        <xsl:with-param name="lastGroove" select="$nextGroove"/>
        <xsl:with-param name="lastMeasure" select="."/>
      </xsl:apply-templates>
    </xsl:when>
    <!-- Closing repeat without alternate ending: Loop back if the loop counter hasn't reached the requested times and after-jump repeats are ok. -->
    <xsl:when test="
      barline[not(ending)]/repeat/@direction = 'backward' and
      ($jump = '' or barline[not(ending)]/repeat/@after-jump = 'yes') and
      (if (barline[not(ending)]/repeat/@times) then number(barline[not(ending)]/repeat/@times) else 2) &gt; $repeatCount
    ">
      <xsl:apply-templates select="$repeatMeasure">
        <xsl:with-param name="lastHarmony" select="$nextHarmony"/>
        <xsl:with-param name="repeatMeasure" select="$repeatMeasure"/>
        <xsl:with-param name="repeatCount" select="$repeatCount + 1"/>
        <xsl:with-param name="jump" select="$jump"/>
        <xsl:with-param name="lastGroove" select="$nextGroove"/>
        <xsl:with-param name="lastMeasure" select="."/>
      </xsl:apply-templates>
    </xsl:when>
    <!-- Alternate ending end: Jump back to loop start if next loop counter is mentioned in any alternate ending for the current repeat block. -->
    <xsl:when test="barline[ending/@type = 'stop']/repeat/@direction = 'backward' and $repeatMeasure/following-sibling::measure[
      preceding-sibling::measure[barline/repeat/@direction = 'forward'][1][generate-id(.) = generate-id($repeatMeasure)] and
      barline/ending/@type = 'start'
      and index-of(tokenize(barline/ending[@type = 'start']/@number, '\s*,\s*'), format-number($repeatCount + 1, '0'))
    ]">
      <xsl:apply-templates select="$repeatMeasure">
        <xsl:with-param name="lastHarmony" select="$nextHarmony"/>
        <xsl:with-param name="repeatMeasure" select="$repeatMeasure"/>
        <xsl:with-param name="repeatCount" select="$repeatCount + 1"/>
        <xsl:with-param name="jump" select="$jump"/>
        <xsl:with-param name="lastGroove" select="$nextGroove"/>
        <xsl:with-param name="lastMeasure" select="."/>
      </xsl:apply-templates>
    </xsl:when>
    <!-- Da capo: Go back to start. -->
    <xsl:when test="*/sound/@dacapo = 'yes' and not($jump = 'capo')">
      <xsl:apply-templates select="//measure[1]">
        <xsl:with-param name="lastHarmony" select="$nextHarmony"/>
        <xsl:with-param name="repeatMeasure" select="//measure[1]"/>
        <xsl:with-param name="repeatCount" select="1"/>
        <xsl:with-param name="jump" select="'capo'"/>
        <xsl:with-param name="lastGroove" select="$nextGroove"/>
        <xsl:with-param name="lastMeasure" select="."/>
      </xsl:apply-templates>
    </xsl:when>
    <!-- Dal segno: Go back to labeled sign. -->
    <xsl:when test="*/sound[@dalsegno] and not($jump = */sound/@dalsegno)">
      <xsl:variable name="segno" select="*/sound/@dalsegno"/>
      <xsl:apply-templates select="preceding-sibling::measure[*/sound/@segno = $segno]">
        <xsl:with-param name="lastHarmony" select="$nextHarmony"/>
        <xsl:with-param name="repeatMeasure" select="//measure[1]"/>
        <xsl:with-param name="repeatCount" select="1"/>
        <xsl:with-param name="jump" select="$segno"/>
        <xsl:with-param name="lastGroove" select="$nextGroove"/>
        <xsl:with-param name="lastMeasure" select="."/>
      </xsl:apply-templates>
    </xsl:when>
    <!-- Closing repeat without alternate ending: Go straight and reset state if the loop counter has reached the requested times. -->
    <xsl:when test="barline[not(ending)]/repeat/@direction = 'backward' and number(barline/repeat/@times) &lt;= $repeatCount">
      <xsl:apply-templates select="following-sibling::measure[1]">
        <xsl:with-param name="lastHarmony" select="$nextHarmony"/>
        <xsl:with-param name="repeatMeasure" select="//measure[1]"/>
        <xsl:with-param name="repeatCount" select="1"/>
        <xsl:with-param name="jump" select="$jump"/>
        <xsl:with-param name="lastGroove" select="$nextGroove"/>
        <xsl:with-param name="lastMeasure" select="."/>
      </xsl:apply-templates>
    </xsl:when>
    <!-- General case: Keep going straight, remembering current state. -->
    <xsl:otherwise>
      <xsl:apply-templates select="following-sibling::measure[1]">
        <xsl:with-param name="lastHarmony" select="$nextHarmony"/>
        <xsl:with-param name="repeatMeasure" select="$repeatMeasure"/>
        <xsl:with-param name="repeatCount" select="$repeatCount"/>
        <xsl:with-param name="jump" select="$jump"/>
        <xsl:with-param name="lastGroove" select="$nextGroove"/>
        <xsl:with-param name="lastMeasure" select="."/>
      </xsl:apply-templates>
    </xsl:otherwise>
  </xsl:choose>

</xsl:otherwise></xsl:choose>
</xsl:template>

<xsl:template match="harmony" mode="sequence">
  <xsl:param name="start"/>
  <xsl:variable name="id" select="generate-id(.)"/>
  <xsl:if test="$start = 1">
Chord-Custom Sequence { </xsl:if>
  <xsl:value-of select="$start"/><xsl:text> </xsl:text>
  <!--
    Calculate this chord's duration.

    The following sum() function accumulates the durations of all notes following the current harmony element
    until the next harmony element. It skips chord notes which don't contribute additional duration.
    The sum is divided by $divisions which is the global time resolution of the whole score.
    The final duration is expressed in "beats" == quarter note time.
  -->
  <xsl:variable name="duration"><xsl:value-of select="sum(following-sibling::note[not(chord) and generate-id(preceding-sibling::harmony[1]) = $id]/duration) div $divisions"/></xsl:variable>
  <!-- Express the duration in MIDI ticks = 192 * quarter note -->
  <xsl:value-of select="$duration * 192"/><xsl:text>t </xsl:text>
  <xsl:value-of select="$chordVolume"/><xsl:text>; </xsl:text>
  <xsl:apply-templates select="following-sibling::harmony[1]" mode="sequence">
    <xsl:with-param name="start" select="$start + $duration"/>
  </xsl:apply-templates>
  <xsl:if test="count(following-sibling::harmony) = 0">}</xsl:if>
</xsl:template>

<xsl:function name="mma:noteValue" as="xs:integer">
  <xsl:param name="step"/>
  <xsl:param name="alter"/>
  <xsl:choose>
    <xsl:when test="($step = 'G' and $alter = '1') or ($step = 'A' and $alter = '-1')"><xsl:sequence select="-4"/></xsl:when>
    <xsl:when test="($step = 'A' and $alter = '1') or ($step = 'B' and $alter = '-1')"><xsl:sequence select="-2"/></xsl:when>
    <xsl:when test="($step = 'C' and $alter = '1') or ($step = 'D' and $alter = '-1')"><xsl:sequence select="1"/></xsl:when>
    <xsl:when test="($step = 'D' and $alter = '1') or ($step = 'E' and $alter = '-1')"><xsl:sequence select="3"/></xsl:when>
    <xsl:when test="($step = 'G' and $alter = '-1')"><xsl:sequence select="-6"/></xsl:when>
    <xsl:when test="($step = 'C' and $alter = '-1')"><xsl:sequence select="-1"/></xsl:when>
    <xsl:when test="($step = 'B' and $alter = '1')"><xsl:sequence select="0"/></xsl:when>
    <xsl:when test="($step = 'F' and $alter = '-1')"><xsl:sequence select="4"/></xsl:when>
    <xsl:when test="($step = 'E' and $alter = '1')"><xsl:sequence select="5"/></xsl:when>
    <xsl:when test="($step = 'F' and $alter = '1')"><xsl:sequence select="6"/></xsl:when>
    <xsl:when test="$step = 'G'"><xsl:sequence select="-5"/></xsl:when>
    <xsl:when test="$step = 'A'"><xsl:sequence select="-3"/></xsl:when>
    <xsl:when test="$step = 'D'"><xsl:sequence select="2"/></xsl:when>
    <xsl:when test="$step = 'B'"><xsl:sequence select="-1"/></xsl:when>
    <xsl:when test="$step = 'C'"><xsl:sequence select="0"/></xsl:when>
    <xsl:when test="$step = 'E'"><xsl:sequence select="4"/></xsl:when>
    <xsl:when test="$step = 'F'"><xsl:sequence select="5"/></xsl:when>
  </xsl:choose>
</xsl:function>

<xsl:template match="harmony" mode="name">
  <xsl:param name="definition"/>
  <xsl:choose>
    <!-- N.C. is expressed as "z" in MMA. -->
    <xsl:when test="kind = 'none'">z</xsl:when>
    <xsl:otherwise>
      <xsl:value-of select="root/root-step"/>
      <xsl:value-of select="if (root/root-alter = '1') then '#' else if (root/root-alter = '-1') then 'b' else ''"/>
      <!-- https://www.w3.org/2021/06/musicxml40/musicxml-reference/data-types/kind-value/ -->
      <xsl:choose>
        <xsl:when test="kind = 'augmented'">+</xsl:when>
        <xsl:when test="kind = 'augmented-seventh'">+7</xsl:when>
        <xsl:when test="kind = 'diminished'">dim</xsl:when>
        <xsl:when test="kind = 'diminished-seventh'">dim7</xsl:when>
        <xsl:when test="kind = 'dominant'">7</xsl:when>
        <xsl:when test="kind = 'dominant-11th'">11</xsl:when>
        <xsl:when test="kind = 'dominant-13th'">13</xsl:when>
        <xsl:when test="kind = 'dominant-ninth'">9</xsl:when>
        <xsl:when test="kind = 'French'"><!-- TODO --></xsl:when>
        <xsl:when test="kind = 'German'"><!-- TODO --></xsl:when>
        <xsl:when test="kind = 'half-diminished'">7b5</xsl:when>
        <xsl:when test="kind = 'Italian'"><!-- TODO --></xsl:when>
        <xsl:when test="kind = 'major'"></xsl:when>
        <xsl:when test="kind = 'major-11th'">M11</xsl:when>
        <xsl:when test="kind = 'major-13th'">M13</xsl:when>
        <xsl:when test="kind = 'major-minor'">mM7</xsl:when>
        <xsl:when test="kind = 'major-ninth'">M9</xsl:when>
        <xsl:when test="kind = 'major-seventh'">M7</xsl:when>
        <xsl:when test="kind = 'major-sixth'">6</xsl:when>
        <xsl:when test="kind = 'minor'">m</xsl:when>
        <xsl:when test="kind = 'minor-11th'">m11</xsl:when>
        <xsl:when test="kind = 'minor-13th'">m13</xsl:when>
        <xsl:when test="kind = 'minor-ninth'">m9</xsl:when>
        <xsl:when test="kind = 'minor-seventh'">m7</xsl:when>
        <xsl:when test="kind = 'minor-sixth'">m6</xsl:when>
        <xsl:when test="kind = 'Neapolitan'"><!-- TODO --></xsl:when>
        <xsl:when test="kind = 'other'"><!-- TODO --></xsl:when>
        <xsl:when test="kind = 'pedal'"><!-- TODO --></xsl:when>
        <xsl:when test="kind = 'power'">5</xsl:when>
        <xsl:when test="kind = 'suspended-fourth'">sus</xsl:when>
        <xsl:when test="kind = 'suspended-second'">sus2</xsl:when>
        <xsl:when test="kind = 'Tristan'"><!-- TODO --></xsl:when>
      </xsl:choose>
      <!--
        Handle modified degrees.

        We try our best to have a rational naming algorithm, and we resort to DefChord when MMA does not recognize our chords:
        - Detect add 4, omit 3 => sus
        - Detect add 2, omit 3 => sus2
        - Detect alter #5 => +
        - Altered degrees: expecting either sharp or flat alterations
        - Added degrees except for sus/sus2: emit (addX) if no alteration. Special case for 7 => M7 when adding this degree.
        - Omitted degrees except for sus/sus2: alterations are not expected

        This algorithm misses some cases. We could try to detect them but it's easier to use MMA's DefChord
        to define our output as synonyms to existing chords. Use `npm run print:chord "sus(addb9)"` to print the syntax for an existing
        code definition that needs to be cloned.
      -->
      <xsl:variable name="sus">
        <xsl:choose>
          <xsl:when test="degree[degree-type = 'add' and degree-value = '4'] and degree[degree-type = 'subtract' and degree-value = '3']">sus</xsl:when>
          <xsl:when test="degree[degree-type = 'add' and degree-value = '2'] and degree[degree-type = 'subtract' and degree-value = '3']">sus2</xsl:when>
          <xsl:when test="degree[degree-type = 'alter' and degree-value = '5' and degree-alter = '1']">+</xsl:when>
          <xsl:otherwise></xsl:otherwise>
        </xsl:choose>
      </xsl:variable>
      <xsl:value-of select="$sus"/>
      <xsl:for-each select="degree[degree-type = 'subtract' and not(degree-value = '3' and not($sus = ''))]">
        <xsl:text>(omit</xsl:text>
        <xsl:value-of select="degree-value"/>
        <xsl:text>)</xsl:text>
      </xsl:for-each>
      <xsl:for-each select="degree[degree-type = 'alter' and not(degree-value = '5' and not($sus = ''))]">
        <xsl:value-of select="if (degree-alter = '1') then '#' else if (degree-alter = '-1') then 'b' else ''"/>
        <xsl:value-of select="degree-value"/>
      </xsl:for-each>
      <xsl:for-each select="degree[degree-type = 'add' and not((degree-value = '4' or degree-value = '2') and not($sus = ''))]">
        <xsl:value-of select="if (degree-alter = '1') then '#' else if (degree-alter = '-1') then 'b' else '(add'"/>
        <xsl:value-of select="if (degree-value = '7' and degree-alter = '0') then 'M7' else degree-value"/>
        <xsl:value-of select="if (degree-alter = '1') then '' else if (degree-alter = '-1') then '' else ')'"/>
      </xsl:for-each>
      <!-- Handle bass note. -->
      <xsl:if test="bass">
        <xsl:choose>
          <xsl:when test="$definition">
            <xsl:text>/</xsl:text>
            <xsl:value-of select="bass/bass-step"/>
            <xsl:value-of select="if (bass/bass-alter = '1') then '#' else if (bass/bass-alter = '-1') then 'b' else ''"/>
          </xsl:when>
          <xsl:otherwise>
            <xsl:text>\</xsl:text>
            <xsl:value-of select="((((mma:noteValue(bass/bass-step, bass/bass-alter) - mma:noteValue(root/root-step, root/root-alter)) mod 12) - 12) mod 12)"/>
          </xsl:otherwise>
        </xsl:choose>
      </xsl:if>
    </xsl:otherwise>
  </xsl:choose>
</xsl:template>

<xsl:template match="harmony" mode="chords">
  <xsl:param name="start"/>
  <xsl:variable name="id" select="generate-id(.)"/>
  <xsl:text> </xsl:text>
  <!-- Chord name. -->
  <xsl:apply-templates select="." mode="name"/>
  <!-- Chord onset. -->
  <xsl:text>@</xsl:text><xsl:value-of select="$start"/>
  <!-- Advance to next chord. -->
  <xsl:variable name="duration"><xsl:value-of select="sum(following-sibling::note[not(chord) and generate-id(preceding-sibling::harmony[1]) = $id]/duration) div $divisions"/></xsl:variable>
  <xsl:apply-templates select="following-sibling::harmony[1]" mode="chords">
    <xsl:with-param name="start" select="$start + $duration"/>
  </xsl:apply-templates>
</xsl:template>

<xsl:template match="note" mode="duration">
  <xsl:param name="duration"/>
  <xsl:variable name="tie" select="if (cue) then notations/tied else tie"/>
  <xsl:choose>
    <xsl:when test="$tie[@type = 'stop'] and not($tie[@type = 'start'])"><xsl:value-of select="$duration + duration"/></xsl:when>
    <xsl:otherwise>
      <xsl:variable name="recursiveDuration">
        <xsl:apply-templates select="if (following-sibling::note[not(chord)]) then following-sibling::note[not(chord)][1] else ../following-sibling::measure[1]/note[not(chord)][1]" mode="duration">
          <xsl:with-param name="duration" select="duration + $duration"/>
        </xsl:apply-templates>
      </xsl:variable>
      <xsl:value-of select="$recursiveDuration"/>
    </xsl:otherwise>
  </xsl:choose>
</xsl:template>

<xsl:template match="note">
  <xsl:param name="shouldIgnoreTieStop" as="xs:boolean"/>
  <xsl:param name="isAnyNotePrinted" as="xs:boolean"/>
  <!--
    A note sequence (SOLO track in MMA glossary) is made of several pieces:
    - Opening bracket "{" to start measure
    - For non-chord notes and non-stopping ties, a duration expressed in MIDI ticks. The duration is computed recursively in the case of ties.
    - For pitched notes, the lower-case note + accidental + octave (4 is the base octave)
    - For rests and cue notes, "r"
    - A tilde "~" in case a tie carries over from previous and/or to next measure
    - A comma "," for next chord note
    - A semicolon for next non-chord note
    - Closing bracket "}" to end measure

    TODO Handle the following:
    - Articulations
    - Sound directives
    - Chords with unequal ties
    - Unpitched notes
  -->
  <xsl:variable name="tie" select="if (cue) then notations/tied else tie"/>
  <xsl:variable name="tieStop" select="$tie[@type = 'stop'] and not($shouldIgnoreTieStop)"/>
  <xsl:variable name="tieStart" select="$tie[@type = 'start']"/>

  <xsl:if test="count(preceding-sibling::note) = 0">
    <xsl:text> {</xsl:text>
    <xsl:if test="$tieStop">~</xsl:if>
  </xsl:if>

  <xsl:if test="not(chord or $tieStop)">
    <xsl:variable name="duration">
      <xsl:choose>
        <xsl:when test="$tieStart">
          <xsl:apply-templates select="." mode="duration">
            <xsl:with-param name="duration" select="0"/>
          </xsl:apply-templates>
        </xsl:when>
        <xsl:otherwise>
          <xsl:value-of select="duration"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:if test="$duration != ''">
      <xsl:if test="$isAnyNotePrinted">;</xsl:if>
      <xsl:value-of select="192 * $duration div $divisions"/>
      <xsl:text>t</xsl:text>
    </xsl:if>
  </xsl:if>

  <xsl:if test="not($tieStop)">
    <xsl:choose>
      <xsl:when test="rest or cue">r</xsl:when>
      <xsl:when test="pitch">
        <xsl:if test="chord"><xsl:text>,</xsl:text></xsl:if>
        <xsl:value-of select="lower-case(pitch/step)"/>
        <xsl:value-of disable-output-escaping="yes" select="if (pitch/alter = '1') then '#' else if (pitch/alter = '-1') then '&amp;' else ''"/>
        <xsl:choose>
          <xsl:when test="pitch/octave &gt; 4">
            <xsl:for-each select="1 to xs:integer(pitch/octave - 4)">+</xsl:for-each>
          </xsl:when>
          <xsl:when test="pitch/octave &lt; 4">
            <xsl:for-each select="1 to xs:integer(4 - pitch/octave)">-</xsl:for-each>
          </xsl:when>
        </xsl:choose>
      </xsl:when>
    </xsl:choose>
  </xsl:if>

  <xsl:if test="count(following-sibling::note) = 0">
    <xsl:if test="not($isAnyNotePrinted or not(chord or $tieStop))">
      <xsl:text disable-output-escaping="yes">&lt;&gt;</xsl:text>
    </xsl:if>
    <xsl:if test="$tieStart">~</xsl:if>
    <xsl:text>;}</xsl:text>
  </xsl:if>

  <xsl:apply-templates select="following-sibling::note[1]">
    <xsl:with-param name="shouldIgnoreTieStop" select="false()"/>
    <xsl:with-param name="isAnyNotePrinted" select="$isAnyNotePrinted or not(chord or $tieStop)"/>
  </xsl:apply-templates>
</xsl:template>

<xsl:template match="other-play" mode="groove">
  <!--
      TODO Perform complete mapping between iReal Pro grooves and MMA grooves.
      Use `npm run print:grooves` to list all available MMA grooves.
    -->
  <xsl:choose>
    <xsl:when test="contains(lower-case(.), 'swing') or contains(lower-case(.), 'jazz')">
      <xsl:choose>
        <xsl:when test="$beats = 5 and $beatType = 4">Jazz54</xsl:when>
        <xsl:otherwise>Swing</xsl:otherwise>
      </xsl:choose>
    </xsl:when>
     <xsl:otherwise></xsl:otherwise>
  </xsl:choose>
</xsl:template>

<xsl:template match="sound" mode="tempo">
Tempo <xsl:value-of select="@tempo"/>
</xsl:template>

<!-- Time signature in MMA is expressed as "number of quarter notes in a measure". -->
<xsl:template match="time">
Time <xsl:value-of select="beats * 4 div beat-type"/>
TimeSig <xsl:value-of select="beats"/>/<xsl:value-of select="beat-type"/>
</xsl:template>

<xsl:template match="harmony" mode="slash">
@Slash <xsl:apply-templates select="." mode="name">
  <xsl:with-param name="definition" select="true()"/>
</xsl:apply-templates>
</xsl:template>

</xsl:stylesheet>

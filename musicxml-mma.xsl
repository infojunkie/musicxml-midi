<?xml version="1.0" encoding="UTF-8"?>
<xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
  xmlns:xs="http://www.w3.org/2001/XMLSchema"
  xmlns:mma="http://www.mellowood.ca/mma"
  exclude-result-prefixes="xs mma"
  version="2.0"
>
<xsl:output media-type="text/plain" omit-xml-declaration="yes"/>

<!-- Inspired by https://github.com/k8bushlover/XSLT-MusicXmlToSessionBand - I love k8bush too! -->

<xsl:param name="chordVolume" select="50"/>

<xsl:variable name="divisions" select="score-partwise/part/measure/attributes/divisions"/>
<xsl:variable name="beats" select="score-partwise/part/measure/attributes/time/beats"/>
<xsl:variable name="beatType" select="score-partwise/part/measure/attributes/time/beat-type"/>

<xsl:template match="score-partwise">
// Generated by musicxml-mma converter https://github.com/infojunkie/musicxml-mma

// Custom chord voice
Begin Chord-Custom
  Voice Piano1
  Octave 5
  Articulate 80
  Volume f
End

Solo Voice TenorSax

// Custom chord definitions
DefChord 7(add6) (0, 4, 7, 9, 10) (0, 2, 4, 5, 7, 9, 10)
DefChord +(addM7)(add9) (0, 4, 8, 11, 14) (0, 2, 4, 5, 8, 9, 11)
DefChord 7+#9 (0, 4, 8, 10, 15) (0, 3, 4, 5, 8, 9, 10)
DefChord M7+ (0, 4, 8, 11) (0, 2, 4, 5, 8, 9, 11)
DefChord dimb13 (0, 3, 6, 9, 8) (0, 2, 3, 5, 6, 8, 9)
DefChord m7+#9 (0, 3, 8, 10, 15) (0, 3, 3, 5, 8, 8, 10)
DefChord m7+b9 (0, 3, 8, 10, 13) (0, 1, 3, 5, 8, 8, 10)
DefChord m7+b9#11 (0, 3, 8, 10, 13, 18) (0, 1, 3, 6, 8, 9, 10)
DefChord m7+ (0, 3, 7, 11) (0, 2, 3, 5, 7, 8, 11)
DefChord (omit3)(add9) (0, 0, 7, 14) (0, 2, 4, 5, 7, 9, 10)
DefChord sus#9 (0, 5, 7, 15) (0, 2, 5, 5, 7, 9, 11)
DefChord susb9 (0, 5, 7, 13) (0, 2, 5, 5, 7, 9, 11)
  <xsl:apply-templates select="part/measure[1]">
    <xsl:with-param name="lastHarmony"/>
    <xsl:with-param name="repeatMeasure"/>
    <xsl:with-param name="repeatCount" select="1"/>
    <xsl:with-param name="jump"/>
    <xsl:with-param name="groove"/>
  </xsl:apply-templates>
</xsl:template>

<!--
  Unroll the repeats and jumps into a linear sequence of measures. To do this, we advance measure by measure, carrying a state made of:
  - Last chord we saw (to set in current measure in case it's empty)
  - Current loop starting measure, typically indicated by a forward-facing repeat barline
  - Current loop counter
  - Current jump status
  Based on the current measure's repeats and jumps, and the current state, we choose which measure to output next.
-->
<xsl:template match="measure">
  <xsl:param name="lastHarmony"/>
  <xsl:param name="repeatMeasure"/>
  <xsl:param name="repeatCount" as="xs:integer"/>
  <xsl:param name="jump"/>
  <xsl:param name="groove"/>
  <xsl:variable name="nextHarmony" select="if (count(harmony) = 0) then generate-id(//harmony[generate-id(.) = $lastHarmony]) else generate-id(harmony[last()])"/>
  <xsl:variable name="repeatMeasureReal" select="if ($repeatMeasure) then $repeatMeasure else generate-id(//measure[1])"/>
  <xsl:variable name="nextGroove" select="if (*/sound/play/other-play[@type = 'groove']) then */sound/play/other-play[@type = 'groove'] else $groove"/>

  <!-- Alternate ending start: Skip to the matching following alternate ending if the loop counter isn't mentioned in the current ending. -->
  <xsl:choose><xsl:when test="barline[ending/@type = 'start'] and not(index-of(tokenize(barline/ending[@type = 'start']/@number, '\s*,\s*'), format-number($repeatCount, '0')))">
    <xsl:apply-templates select="following-sibling::measure[barline/ending/@type = 'start' and index-of(tokenize(barline/ending[@type = 'start']/@number, '\s*,\s*'), format-number($repeatCount, '0'))][1]">
      <xsl:with-param name="lastHarmony" select="$nextHarmony"/>
      <xsl:with-param name="repeatMeasure" select="$repeatMeasure"/>
      <xsl:with-param name="repeatCount" select="$repeatCount"/>
      <xsl:with-param name="jump" select="$jump"/>
      <xsl:with-param name="groove" select="$nextGroove"/>
    </xsl:apply-templates>
  </xsl:when>
  <xsl:otherwise>

  <!-- Set the time signature and tempo if this is the first iteration in a loop. -->
  <xsl:if test="$repeatCount = 1 and $jump = ''">
    <xsl:apply-templates select="*/sound/play/other-play[@type = 'groove']" mode="groove"/>
    <xsl:apply-templates select="attributes/time"/>
    <xsl:apply-templates select="direction/sound[@tempo]" mode="tempo"/>
  </xsl:if>

  <!-- If we don't have a groove, add our hand-made chord sequence that replicates the rhythm notation of the chords. -->
  <xsl:if test="not($nextGroove)">
    <xsl:apply-templates select="harmony[1]" mode="sequence">
      <xsl:with-param name="start" select="1"/>
    </xsl:apply-templates>
    <xsl:if test="count(harmony) = 0">
      <!-- In case of no chord in this measure, get the last chord of the closest preceding measure that had a chord. -->
      <xsl:apply-templates select="//harmony[generate-id(.) = $lastHarmony]" mode="sequence">
        <xsl:with-param name="start" select="1"/>
      </xsl:apply-templates>
    </xsl:if>
  </xsl:if>

  <!-- Measure number. -->
  <xsl:text>&#xa;</xsl:text>
  <xsl:text>MidiMark Measure:</xsl:text><xsl:value-of select="@number"/>
  <xsl:text>&#xa;</xsl:text>
  <xsl:value-of select="@number"/>

  <!-- Chord information. -->
  <xsl:apply-templates select="harmony[1]" mode="chords">
    <xsl:with-param name="start" select="1"/>
  </xsl:apply-templates>
  <xsl:if test="count(harmony) = 0">
    <!-- In case of no chord in this measure, get the last chord of the closest preceding measure that had a chord. -->
    <xsl:if test="not($lastHarmony)"> z</xsl:if>
    <xsl:apply-templates select="//harmony[generate-id(.) = $lastHarmony]" mode="chords">
      <xsl:with-param name="start" select="1"/>
    </xsl:apply-templates>
  </xsl:if>

  <!-- Notes information. -->
  <xsl:apply-templates select="note[1]"/>

  <!-- Advance to next measure with our unrolling algorithm. -->
  <xsl:choose>
    <!-- Fine: Stop everything
         TODO Handle sound/@time-only for alternate endings.
    -->
    <xsl:when test="*/sound/@fine = 'yes' and not($jump = '')">
    </xsl:when>
    <!-- To Coda: Jump forward to labeled coda
         TODO Handle sound/@time-only for alternate endings.
    -->
    <xsl:when test="*/sound[@tocoda] and not($jump = '')">
      <xsl:variable name="coda" select="*/sound/@tocoda"/>
      <xsl:apply-templates select="following-sibling::measure[*/sound/@coda = $coda]">
        <xsl:with-param name="lastHarmony"/>
        <xsl:with-param name="repeatMeasure"/>
        <xsl:with-param name="repeatCount" select="1"/>
        <xsl:with-param name="jump" select="$coda"/>
        <xsl:with-param name="groove" select="$nextGroove"/>
      </xsl:apply-templates>
    </xsl:when>
    <!-- Opening repeat: Save this measure as the loop start. Reset loop counter to 1 unless we're already looping.
         TODO Handle sound/@forward-repeat attribute for the same effect.
    -->
    <xsl:when test="barline/repeat/@direction = 'forward' or generate-id(.) = $repeatMeasure">
      <xsl:apply-templates select="following-sibling::measure[1]">
        <xsl:with-param name="lastHarmony" select="$nextHarmony"/>
        <xsl:with-param name="repeatMeasure" select="generate-id(.)"/>
        <xsl:with-param name="repeatCount" select="if (generate-id(.) = $repeatMeasure) then $repeatCount else 1"/>
        <xsl:with-param name="jump" select="$jump"/>
        <xsl:with-param name="groove" select="$nextGroove"/>
      </xsl:apply-templates>
    </xsl:when>
    <!-- Closing repeat without alternate ending: Loop back if the loop counter hasn't reached the requested times and after-jump repeats are ok. -->
    <xsl:when test="
      barline[not(ending)]/repeat/@direction = 'backward' and
      ($jump = '' or barline[not(ending)]/repeat/@after-jump = 'yes') and
      (if (barline[not(ending)]/repeat/@times) then number(barline[not(ending)]/repeat/@times) else 2) &gt; $repeatCount
    ">
      <xsl:apply-templates select="//measure[generate-id(.) = $repeatMeasureReal]">
        <xsl:with-param name="lastHarmony" select="$nextHarmony"/>
        <xsl:with-param name="repeatMeasure" select="$repeatMeasureReal"/>
        <xsl:with-param name="repeatCount" select="$repeatCount + 1"/>
        <xsl:with-param name="jump" select="$jump"/>
        <xsl:with-param name="groove" select="$nextGroove"/>
      </xsl:apply-templates>
    </xsl:when>
    <!-- Alternate ending end: Jump back to loop start if next loop counter is mentioned in any alternate ending for the current repeat block. -->
    <xsl:when test="barline[ending/@type = 'stop']/repeat/@direction = 'backward' and //measure[generate-id(.) = $repeatMeasureReal]/following-sibling::measure[
      preceding-sibling::measure[barline/repeat/@direction = 'forward'][1][generate-id(.) = $repeatMeasureReal] and
      barline/ending/@type = 'start'
      and index-of(tokenize(barline/ending[@type = 'start']/@number, '\s*,\s*'), format-number($repeatCount + 1, '0'))
    ]">
      <xsl:apply-templates select="//measure[generate-id(.) = $repeatMeasureReal]">
        <xsl:with-param name="lastHarmony" select="$nextHarmony"/>
        <xsl:with-param name="repeatMeasure" select="$repeatMeasureReal"/>
        <xsl:with-param name="repeatCount" select="$repeatCount + 1"/>
        <xsl:with-param name="jump" select="$jump"/>
        <xsl:with-param name="groove" select="$nextGroove"/>
      </xsl:apply-templates>
    </xsl:when>
    <!-- Da capo: Go back to start. -->
    <xsl:when test="*/sound/@dacapo = 'yes' and not($jump = 'capo')">
      <xsl:apply-templates select="//measure[1]">
        <xsl:with-param name="lastHarmony" select="$nextHarmony"/>
        <xsl:with-param name="repeatMeasure"/>
        <xsl:with-param name="repeatCount" select="1"/>
        <xsl:with-param name="jump" select="capo"/>
        <xsl:with-param name="groove" select="$nextGroove"/>
      </xsl:apply-templates>
    </xsl:when>
    <!-- Dal segno: Go back to labeled sign. -->
    <xsl:when test="*/sound[@dalsegno] and not($jump = */sound/@dalsegno)">
      <xsl:variable name="segno" select="*/sound/@dalsegno"/>
      <xsl:apply-templates select="preceding-sibling::measure[*/sound/@segno = $segno]">
        <xsl:with-param name="lastHarmony" select="$nextHarmony"/>
        <xsl:with-param name="repeatMeasure"/>
        <xsl:with-param name="repeatCount" select="1"/>
        <xsl:with-param name="jump" select="@segno"/>
        <xsl:with-param name="groove" select="$nextGroove"/>
      </xsl:apply-templates>
    </xsl:when>
    <!-- Closing repeat without alternate ending: Go straight and reset state if the loop counter has reached the requested times. -->
    <xsl:when test="barline[not(ending)]/repeat/@direction = 'backward' and number(barline/repeat/@times) &lt;= $repeatCount">
      <xsl:apply-templates select="following-sibling::measure[1]">
        <xsl:with-param name="lastHarmony" select="$nextHarmony"/>
        <xsl:with-param name="repeatMeasure"/>
        <xsl:with-param name="repeatCount" select="1"/>
        <xsl:with-param name="jump" select="$jump"/>
        <xsl:with-param name="groove" select="$nextGroove"/>
      </xsl:apply-templates>
    </xsl:when>
    <!-- General case: Keep going straight, remembering current state. -->
    <xsl:otherwise>
      <xsl:apply-templates select="following-sibling::measure[1]">
        <xsl:with-param name="lastHarmony" select="$nextHarmony"/>
        <xsl:with-param name="repeatMeasure" select="$repeatMeasure"/>
        <xsl:with-param name="repeatCount" select="$repeatCount"/>
        <xsl:with-param name="jump" select="$jump"/>
        <xsl:with-param name="groove" select="$nextGroove"/>
      </xsl:apply-templates>
    </xsl:otherwise>
  </xsl:choose>

</xsl:otherwise></xsl:choose>
</xsl:template>

<xsl:template match="harmony" mode="sequence">
  <xsl:param name="start"/>
  <xsl:variable name="id" select="generate-id(.)"/>
  <xsl:if test="$start = 1">
Chord-Custom Sequence { </xsl:if>
  <xsl:value-of select="$start"/><xsl:text> </xsl:text>
  <!--
    Calculate this chord's duration.

    The following sum() function accumulates the durations of all notes following the current harmony element
    until the next harmony element. It skips chord notes which don't contribute additional duration.
    The sum is divided by $divisions which is the global time resolution of the whole score.
    The final duration is expressed in "beats" == quarter note time.
  -->
  <xsl:variable name="duration"><xsl:value-of select="sum(following-sibling::note[not(chord) and generate-id(preceding-sibling::harmony[1]) = $id]/duration) div $divisions"/></xsl:variable>
  <!-- Express the duration in MIDI ticks = 192 * quarter note -->
  <xsl:value-of select="$duration * 192"/><xsl:text>t </xsl:text>
  <xsl:value-of select="$chordVolume"/><xsl:text>; </xsl:text>
  <xsl:apply-templates select="following-sibling::harmony[1]" mode="sequence">
    <xsl:with-param name="start" select="$start + $duration"/>
  </xsl:apply-templates>
  <xsl:if test="count(following-sibling::harmony) = 0">}</xsl:if>
</xsl:template>

<xsl:template match="harmony" mode="chords">
  <xsl:param name="start"/>
  <xsl:variable name="id" select="generate-id(.)"/>
  <xsl:text> </xsl:text>
  <xsl:choose>
    <!-- N.C. is expressed as "z" in MMA. -->
    <xsl:when test="kind = 'none'">z</xsl:when>
    <xsl:otherwise>
      <xsl:value-of select="root/root-step"/>
      <xsl:value-of select="if (root/root-alter = '1') then '#' else if (root/root-alter = '-1') then 'b' else ''"/>
      <!-- https://www.w3.org/2021/06/musicxml40/musicxml-reference/data-types/kind-value/ -->
      <xsl:choose>
        <xsl:when test="kind = 'augmented'">+</xsl:when>
        <xsl:when test="kind = 'augmented-seventh'">+7</xsl:when>
        <xsl:when test="kind = 'diminished'">dim</xsl:when>
        <xsl:when test="kind = 'diminished-seventh'">dim7</xsl:when>
        <xsl:when test="kind = 'dominant'">7</xsl:when>
        <xsl:when test="kind = 'dominant-11th'">11</xsl:when>
        <xsl:when test="kind = 'dominant-13th'">13</xsl:when>
        <xsl:when test="kind = 'dominant-ninth'">9</xsl:when>
        <xsl:when test="kind = 'French'"><!-- TODO --></xsl:when>
        <xsl:when test="kind = 'German'"><!-- TODO --></xsl:when>
        <xsl:when test="kind = 'half-diminished'">7b5</xsl:when>
        <xsl:when test="kind = 'Italian'"><!-- TODO --></xsl:when>
        <xsl:when test="kind = 'major'"></xsl:when>
        <xsl:when test="kind = 'major-11th'">M11</xsl:when>
        <xsl:when test="kind = 'major-13th'">M13</xsl:when>
        <xsl:when test="kind = 'major-minor'">mM7</xsl:when>
        <xsl:when test="kind = 'major-ninth'">M9</xsl:when>
        <xsl:when test="kind = 'major-seventh'">M7</xsl:when>
        <xsl:when test="kind = 'major-sixth'">6</xsl:when>
        <xsl:when test="kind = 'minor'">m</xsl:when>
        <xsl:when test="kind = 'minor-11th'">m11</xsl:when>
        <xsl:when test="kind = 'minor-13th'">m13</xsl:when>
        <xsl:when test="kind = 'minor-ninth'">m9</xsl:when>
        <xsl:when test="kind = 'minor-seventh'">m7</xsl:when>
        <xsl:when test="kind = 'minor-sixth'">m6</xsl:when>
        <xsl:when test="kind = 'Neapolitan'"><!-- TODO --></xsl:when>
        <xsl:when test="kind = 'other'"><!-- TODO --></xsl:when>
        <xsl:when test="kind = 'pedal'"><!-- TODO --></xsl:when>
        <xsl:when test="kind = 'power'">5</xsl:when>
        <xsl:when test="kind = 'suspended-fourth'">sus</xsl:when>
        <xsl:when test="kind = 'suspended-second'">sus2</xsl:when>
        <xsl:when test="kind = 'Tristan'"><!-- TODO --></xsl:when>
      </xsl:choose>
      <!--
        Handle modified degrees.

        We try our best to have a rational naming algorithm, and we resort to DefChord when MMA does not recognize our chords:
        - Detect add 4, omit 3 => sus
        - Detect add 2, omit 3 => sus2
        - Detect alter #5 => +
        - Altered degrees: expecting either sharp or flat alterations
        - Added degrees except for sus/sus2: emit (addX) if no alteration. Special case for 7 => M7 when adding this degree.
        - Omitted degrees except for sus/sus2: alterations are not expected

        This algorithm misses some cases. We could try to detect them but it's easier to use MMA's DefChord
        to define our output as synonyms to existing chords. Use `npm run debug:chord "sus(addb9)"` to print the syntax for an existing
        code definition that needs to be cloned.
      -->
      <xsl:variable name="sus">
        <xsl:choose>
          <xsl:when test="degree[degree-type = 'add' and degree-value = '4'] and degree[degree-type = 'subtract' and degree-value = '3']">sus</xsl:when>
          <xsl:when test="degree[degree-type = 'add' and degree-value = '2'] and degree[degree-type = 'subtract' and degree-value = '3']">sus2</xsl:when>
          <xsl:when test="degree[degree-type = 'alter' and degree-value = '5' and degree-alter = '1']">+</xsl:when>
          <xsl:otherwise></xsl:otherwise>
        </xsl:choose>
      </xsl:variable>
      <xsl:value-of select="$sus"/>
      <xsl:for-each select="degree[degree-type = 'subtract' and not(degree-value = '3' and not($sus = ''))]">
        <xsl:text>(omit</xsl:text>
        <xsl:value-of select="degree-value"/>
        <xsl:text>)</xsl:text>
      </xsl:for-each>
      <xsl:for-each select="degree[degree-type = 'alter' and not(degree-value = '5' and not($sus = ''))]">
        <xsl:value-of select="if (degree-alter = '1') then '#' else if (degree-alter = '-1') then 'b' else ''"/>
        <xsl:value-of select="degree-value"/>
      </xsl:for-each>
      <xsl:for-each select="degree[degree-type = 'add' and not((degree-value = '4' or degree-value = '2') and not($sus = ''))]">
        <xsl:value-of select="if (degree-alter = '1') then '#' else if (degree-alter = '-1') then 'b' else '(add'"/>
        <xsl:value-of select="if (degree-value = '7' and degree-alter = '0') then 'M7' else degree-value"/>
        <xsl:value-of select="if (degree-alter = '1') then '' else if (degree-alter = '-1') then '' else ')'"/>
      </xsl:for-each>
      <!-- Handle bass note. -->
      <xsl:if test="bass">
        <xsl:text>/</xsl:text>
        <xsl:value-of select="bass/bass-step"/>
        <xsl:value-of select="if (bass/bass-alter = '1') then '#' else if (bass/bass-alter = '-1') then 'b' else ''"/>
      </xsl:if>
    </xsl:otherwise>
  </xsl:choose>
  <!-- Chord onset. -->
  <xsl:text>@</xsl:text><xsl:value-of select="$start"/>
  <!-- Advance to next chord. -->
  <xsl:variable name="duration"><xsl:value-of select="sum(following-sibling::note[not(chord) and generate-id(preceding-sibling::harmony[1]) = $id]/duration) div $divisions"/></xsl:variable>
  <xsl:apply-templates select="following-sibling::harmony[1]" mode="chords">
    <xsl:with-param name="start" select="$start + $duration"/>
  </xsl:apply-templates>
</xsl:template>

<xsl:template match="note" mode="duration">
  <xsl:param name="duration"/>
  <xsl:choose>
    <xsl:when test="tie[@type = 'stop'] and not(tie[@type = 'start'])"><xsl:value-of select="$duration + duration"/></xsl:when>
    <xsl:otherwise>
      <xsl:variable name="recursiveDuration">
        <xsl:apply-templates select="if (following-sibling::note[not(chord)]) then following-sibling::note[not(chord)][1] else ../following-sibling::measure[1]/note[not(chord)][1]" mode="duration">
          <xsl:with-param name="duration" select="duration + $duration"/>
        </xsl:apply-templates>
      </xsl:variable>
      <xsl:value-of select="$recursiveDuration"/>
    </xsl:otherwise>
  </xsl:choose>
</xsl:template>

<xsl:template match="note">
  <!--
    A note sequence (SOLO track in MMA glossary) is made of several pieces:
    - Opening bracket "{" to start measure
    - For non-chord notes and non-stopping ties, a duration expressed in MIDI ticks. The duration is computed recursively in the case of ties.
    - For pitched notes, the lower-case note + accidental + octave (4 is the base octave)
    - For rests and cue notes, "r"
    - A tilde "~" in case a tie carries over from previous or to next measure
    - A comma "," for next chord note
    - A semicolon for next non-chord note
    - Closing bracket "}" to end measure

    TODO Handle the following:
    - Articulations
    - Sound directives
    - Chords with unequal ties
    - Unpitched notes
  -->
  <xsl:if test="count(preceding-sibling::note) = 0"> {</xsl:if>
  <xsl:if test="not(chord)">
    <xsl:variable name="duration">
      <xsl:choose>
        <xsl:when test="tie[@type = 'start'] and tie[@type = 'stop']">
        </xsl:when>
        <xsl:when test="tie[@type = 'start']">
          <xsl:apply-templates select="." mode="duration">
            <xsl:with-param name="duration" select="0"/>
          </xsl:apply-templates>
        </xsl:when>
        <xsl:when test="tie[@type = 'stop']">
        </xsl:when>
        <xsl:otherwise>
          <xsl:value-of select="duration"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:if test="$duration != ''">
      <xsl:value-of select="192 * $duration div $divisions"/>
      <xsl:text>t</xsl:text>
    </xsl:if>
  </xsl:if>
  <xsl:choose>
    <xsl:when test="pitch and not(tie[@type = 'stop'])">
      <xsl:if test="chord"><xsl:text>,</xsl:text></xsl:if>
      <xsl:value-of select="lower-case(pitch/step)"/>
      <xsl:value-of select="if (pitch/alter = '1') then '#' else if (pitch/alter = '-1') then '&amp;' else ''"/>
      <xsl:choose>
        <xsl:when test="pitch/octave &gt; 4">
          <xsl:for-each select="1 to xs:integer(pitch/octave - 4)">+</xsl:for-each>
        </xsl:when>
        <xsl:when test="pitch/octave &lt; 4">
          <xsl:for-each select="1 to xs:integer(4 - pitch/octave)">-</xsl:for-each>
        </xsl:when>
      </xsl:choose>
    </xsl:when>
    <xsl:when test="rest or cue">r</xsl:when>
  </xsl:choose>
  <xsl:if test="count(following-sibling::note) = 0 and tie[@type = 'start']">
    <xsl:if test="not(preceding-sibling::note[not(tie/@type = 'start') and not(tie/@type = 'end')])">
      <xsl:text disable-output-escaping="yes">&lt;&gt;</xsl:text>
    </xsl:if>
    <xsl:text>~</xsl:text>
  </xsl:if>
  <xsl:choose>
    <xsl:when test="count(preceding-sibling::note) = 0 and tie[@type = 'stop']">~</xsl:when>
    <xsl:when test="count(following-sibling::note) = 0">;</xsl:when>
    <xsl:when test="following-sibling::note[1][not(chord)] and not(tie[@type = 'start']) and (count(preceding-sibling::note) = 0 or preceding-sibling::note[not(tie/@type = 'stop')])">;</xsl:when>
  </xsl:choose>
  <xsl:if test="count(following-sibling::note) = 0">}</xsl:if>
  <xsl:apply-templates select="following-sibling::note[1]"/>
</xsl:template>

<xsl:template match="other-play" mode="groove">
Groove <xsl:choose>
    <xsl:when test="contains(lower-case(.), 'swing')">
      <xsl:choose>
        <xsl:when test="$beats = 5 and $beatType = 4">Jazz54</xsl:when>
        <xsl:otherwise>Swing</xsl:otherwise>
      </xsl:choose>
    </xsl:when>
    <xsl:otherwise><xsl:value-of select="."/></xsl:otherwise>
  </xsl:choose>
</xsl:template>

<xsl:template match="sound" mode="tempo">
Tempo <xsl:value-of select="@tempo"/>
</xsl:template>

<xsl:template match="time">
<!-- Time signature in MMA is expressed as "number of quarter notes in a measure". -->
Time <xsl:value-of select="beats * 4 div beat-type"/>
TimeSig <xsl:value-of select="beats"/>/<xsl:value-of select="beat-type"/>
</xsl:template>

</xsl:stylesheet>
